# Задачи к курсу CSC «Алгоритмы: теория и практика. Структуры данных» 
https://stepik.org/course/1547/info

Постановка задач в файле statements.pdf.

**2. Базовые структуры данных.

2.1. Скобки в коде. brace_placement_in_code.py
Проверить, правильно ли расставлены скобки в данном коде.

2.2. Высота дерева. tree_height.py
Вычислить высоту данного дерева.

2.3. Обработка сетевых пакетов. simulating_network_packet_processing.py
Реализовать обработчик сетевых пакетов.

2.4. Стек с поддержкой максимума. max_support_stack.py
Реализовать стек с поддержкой операций push, pop и max.

2.5. Максимум в скользящем окне. max_in_sliding_window.py
Найти максимум в каждом окне размера m данного массива чисел A[1..n].

**3. Очереди с приоритетом.

3.1. Построение кучи. build_heap.py
Переставить элементы заданного массива чисел так, чтобы он удовлетворял свойству мин-кучи:
должны выполняться неравенства A[i] ≤ A[2i + 1] и A[i] ≤ A[2i + 2] для всех i.

3.2. Параллельная обработка. parallel_processing.py
По данным n процессорам и m задач определите, для каждой из задач,
каким процессором она будет обработана.

**4. Системы непересекающихся множеств.

4.1. Объединение таблиц. concatenation_of_tables.py
Реализовать симуляцию объединения таблиц в базе данных.

4.2. Автоматический анализ программ. automatic_program_analysis.py
При автоматическом анализе программ возникает 
задача по решению системы равенств и неравенств:
Проверить, можно ли присвоить переменным целые значения, чтобы
выполнить заданные равенства вида x_i = x_j и неравенства вида x_p != x_q.

**5. Хеш-таблицы.

5.1. Телефонная книга. phone_book.py
Реализовать структуру данных, эффективно обрабатывающую запросы вида:
add number name, del number и find number.

5.2. Хеширование цепочками. hashing_with_chains.py
Реализовать схему хеширования цепочками, 
используя таблицу с m ячейками и полиномиальной хеш-функцией на строках.

5.3. Поиск образца в тексте. finding_pattern_in_text.py
Найти все вхождения строки Pattern в строку Text, используя хеш-функции.

**6. Деревья поиска.

6.1. Обход двоичного дерева. binary_tree_traversal.py
Построить in-order, pre-order и post-order обходы данного двоичного дерева.

6.2. Проверка свойства дерева поиска. checking_property_of_search_tree.py
Проверить, является ли данное двоичное дерево деревом поиска:
верно ли, что для любой вершины дерева её ключ
больше всех ключей в левом поддереве данной вершины и
меньше всех ключей в правом поддереве.

6.3. Проверка более общего свойства дерева поиска. checking_general_property_of_search_tree.py
Данная задача полностью аналогична предыдущей, но проверять теперь нужно более общее свойство. 
Дереву разрешается содержать равные ключи, но они всегда должны находиться в правом поддереве.
Формально, двоичное дерево называется деревом поиска, если для
любой вершины её ключ больше всех ключей из её левого поддерева
и не меньше всех ключей из правого поддерева.

**!! 6.4. Множество с запросами суммы на отрезке. requests_for_sum_on_segment.py

Реализовать структуру данных для хранения множества целых чисел,
поддерживающую запросы добавления, удаления, поиска, а также суммы на отрезке.

Реализация через AVL дерево. В каждом узле хранится сумма всех элементов в поддереве, 
при вставке и удалении пересчитываются суммы связанных поддеревьев.
Сумма на отрезке рассчитывается по формуле: 
сумма всех элементов больших, чем левая граница отрезка - сумма всех элементов больших, чем правая граница.

**!! 6.5. Rope. rope.py

Реализовать структуру данных Rope. Данная структура данных хранит строку 
и позволяет эффективно вырезать кусок строки и переставить его в другое место.

Реализация через Splay дерево. См. статью https://habr.com/ru/company/JetBrains-education/blog/210296/
В каждом узле дерева хранится 1 буква, а также размер поддерева, корнем которого является данный узел. 
Размер поддерева необходим для поиска буквы по ее порядковому номеру.
Для вырезания и перестановки кусочка строки используются процедуры split и merge.
